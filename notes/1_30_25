Network Layer
- handled by routers


IP protocol stack: key abstractions
-------------------------------------
Application - Apps
Transport - Reliable streams | Messages
Network - Best effort global packet delivery
Link - Best effort local packet delivery



best-effort global packet delivery

circuit switching (e.g. phone network)
- source establishes connection
	- reserve resources along hops in the path
- source sends data
	- transmit data over the established connection
- source tears down connection
	- free the resources for future connections

circuit switching: static allocation
- time-division
	- each circuit allocation specific time slots
- frequency-division
	- each circuit allocated specific frequencies


packet switching
- message divided into packets
	- packet header identifies the destination address
- packets travel separately through the network
	- forwarding based on dest address
	- packets may be buffered temporarily
- destination reconstructs message


packet switching: statistical (time division) multiplexing
- intuition: traffic generated by computer end-hosts is bursty
	- unlike telephone (e.g. constant 56kbps) -> VoIPm VoLTE
	- can use network resources while others idle
- packet queuing in network
	- tradeoff space for time
	- handle short periods when outgoing link demand > link speed


is best effort good enough?
- packet loss and delay
	- sender resends
- packets follow different paths (out of order arrival)
	- usually doesn't matter?
	- give packets an identifier
- packet corruption
	- receiver detects, sender resends
- network failure
	- drop packet
- out-of-order delivery	
	- receiver reorders data
- network congestion
	- buffer packets
	- drop if necessary

packet vs circuit switching
- predicatable performance - circuit
- network never blocks senders - packet
- reliable, in order delivery - circuit
- low delay to send data - packet
- simple forwarding - circuit
- no overhead for packet headers - circuit
- high utilization under most workloads - packet
- no per-connection network state - packet


network addresses


dominated by IPv4: Internet Protocol version 4

IPv4
- unique 32-bit number
- identifies a network interface
	- on an end-host, router, etc
- represented in dotted-quad notation

e.g.
-    128   .    220   .    13    .    64
- 10000000 | 11011100 | 00001101 | 01000000

grouping related hosts
- internet is an internetwork
	- connects networks together, not hosts
	- need to address a network (i.e. a group of hosts)
- LAN - local area network
- WAN - wide area network

scalability challenge
- if hosts had arbitrary addresses
	- every router would need to know how to forward packets toward every host
	- routers would need a lot of information (billions of entries)

hierarchical addressing: IP prefixes
- network and host portions (left and right)
- 128.220.13.0/24
	- 24 bit (first 3 fields, i.e. 128.220.13) prefix with 2^8 IP addresses

prefixes improve scalability
- number related hosts from a common subnet

easy to connect new hosts
- no need to update router forwarding tables


history of IP address allocation

old way: classful addressing
- class A
	- first bit 0 - IP address < 128.0.0.0
	- very large /8 blocks (e.g. MIT has 18.0.0.0/8
- Class B
	- first bits 10 - IP address < 192.0.0.0
	- large /16 blocks (e.g. JHU has 128.220.0.0/16
- Class C
	- first bits 110 - IP address < 224.0.0.0
	- small /24 blocks (e.g. JHU also has 192.12.13.0/24
- Class D: 1110* multiclass
- Class E: 11110* future use


classful addressing is inefficient
- chunks too large
	- 16,000 allocations uses up entirety of class B
- inefficient use of addresses
	- should someone needing 500 addresses get a class B?
- waste of forwarding table space
	- single entry for every class C


classless inter-domain routing (CIDR)
- use two 32-bit number to represent network
	- network number = IP address AND mask

IP address: 128.220.13.64
IP Mask:    255.254.0.0

10000000 11011100 00001101 01000000
11111111 11111110 00000000 00000000

hierarchical address allocation
- hierarchy is key to scalability
	- addresses allocated in contiguous chunks (prefixes)
	- ISP core routers typically have ~800,000 orefixes in forwarding tables

obtaining a block of addresses
- internet corporation for assigned names and numbers (ICANN)
	- allocates large blocks to regional internet registries
- regional internet registries (RIRs)
	- e.g. ARIN (American Registry for Internet Numbers)
	- allocates to ISPs and large institutions
- Internet service providers (ISPs)
	- allocate address blocks to customers
	- who may in turn allocate to customers
- buy from someone who has extra spaces


IPv4 exhaustion
- IPv6 proposed in december 1996
- IPv6: 32 bits -> 128 bits
- Network address translation (NAT)


packet forwarding


hop-by-hop packet forwarding
- each router has a forwarding table
	- maps dest addr to outgoing interface
- upon receiving a packet
	- check dest addr in IP header
	- index in table
	- determin outgoing interface
	- forward packet out of that interface
- next hop

separate forwarding entry per prefix
- prefix-based forwarding
	- map dest addr to matching prefix
	- forwarding to the outgoing interface

CIDR makes packet forwarding harder
- forwarding table may have many matches

longest matching prefix forwarding
- dest based forwarding
	- packet has a dest addr
	- router identifies longest matching prefix it knows about
	- how to do this very fast? (e.g. PATRICIA tree/trie)

creating a forwarding table
- entries can be statically configured
	- e.g. map 1.2.3.0/24 to Serial0/0.1
- but this doesn't adapt
	- to failures
	- to new equipment
	- to the need to balance load
- that is where the control plane comes in
	- routing protocols


IP vs MAC
- hierarchically allocated - both
- organized topologically - IP
- forwarding via exact match on address - MAC
- per host state in the network - MAC

